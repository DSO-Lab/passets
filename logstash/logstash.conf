input {
    syslog {
	type => "syslog-flow"
        port => 5044
    }
}

filter {
    grok {
        match => {"message" => "<[0-9]+>([0-9|A-Z|a-z|\-|:|\s|,]+) [A-Za-z]+: (?<message>[^\u0000]*)"}
        overwrite => ["message"]
        remove_field => ["severity", "host", "facility_label", "severity_label", "facility", "priority"]
        remove_tag => ["_grokparsefailure_sysloginput"]
    }
    json {
	    source => "message"
    }
    mutate {
        add_field => {
            "host" => "%{ip}:%{port}"
        }
        remove_field => ["message"]
    }
    ruby {
        path => '/usr/share/logstash/config/ip.rb'
        script_params => {
            'inner_ips' => [
                '10.0.0.0-10.255.255.255',
                '172.16.0.0-172.31.255.255',
                '192.168.0.0-192.168.255.255',
                '169.254.0.0-169.254.255.255',
                '127.0.0.1-127.0.0.255'
            ]
        }
    }
    geoip {
        source => "ip"
        target => "geoip"
        fields => ["city_name", "country_name", "longitude", "latitude"]
        database => "/usr/share/logstash/config/GeoLite2-City.mmdb"
        add_field => {
            "[geoip][location][lon]" => "%{[geoip][longitude]}"
            "[geoip][location][lat]" => "%{[geoip][latitude]}"
        }
        remove_field => ["[geoip][longitude]", "[geoip][latitude]"]
    }
    mutate {
        convert => ["[geoip][location]","float"]
    }
    if [pro] == 'HTTP' {
        ruby {
            path => '/usr/share/logstash/config/url.rb'
        }
    }
}

output {
    if "_grokparsefailure" not in [tags] and "_jsonparsefailure" not in [tags] {
        elasticsearch {
            hosts => ["http://passets-elasticsearch:9200/"]
            index => "logstash-passets"
        }
    }
}
